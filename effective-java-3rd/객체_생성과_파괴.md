#   객체 생성과 파괴

##  생성자 대신 정적 팩터리 메서드를 고려하기
- `정적 팩터리 메서드` 장점
  - 이름을 가질 수 있음
  - 호출될 때마다 인스턴스를 생성할 필요가 없음
  - 반환 타입의 하위 타입 객체를 반환할 수 있음
  - 입력 매개변환에 따라 매번 다른 클래스의 객체를 반환할 수 있음
  - 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 됨
- `정적 팩터리 메서드` 단점
  - 정적 팩터리 메서드만 제공하면 하위 클래스 생성 불가
  - 정적 팩터리 메서드는 개발자가 찾기 어려움

##  매개변수가 많으면 builder를 고려하기
- 빌더 패턴 = 안정성(`점층적 생성자 패턴`) + 가독성(`자바 빈즈 패턴`)
- 빌더 패턴은 계층적 클래스와 함께 쓰기 좋음

##  private 생성자나 enum으로 singleton을 보증하기
- 싱글턴 생성 방식
  - public static 멤버가 final 필드인 방식
  - 정적 팩터리 메서드를 public static 멤버로 제공
- 대부분 상황에서 `Enum Type`이 싱글턴을 만드는 데 가장 좋은 방법

##  instance화를 막으려면 private 생성자를 사용하기
- 추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없음
- private 생성자를 추가하면 클래스의 인스턴스화를 막을 수 있음

##  자원을 직접 명시하지 않고, dependency injection하기
- 사용하는 자원에 따라 동작이 달라지는 클래스 --> 정적 유틸 클래스나 싱글턴 방식이 적합하지 않음
- 인스턴스 생성할 때 생성자에서 의존성을 주입함

##  불필요한 객체 생성을 피하기
- Wrapper Class보다 Primitive Type을 사용하기

##  다 쓴 객체 reference를 해제하기
- 해당 참조를 더이상 사용하지 않을 때 `null` 처리
  - `null` 처리는 예외적인 경우에만 사용
- 자기 메모리를 관리하는 클래스라면 개발자는 항상 메모리 누수에 주의해야 함
- 캐시 또한 메모리 누수를 일으키는 주범

##  finalizer와 cleaner 사용을 피하기
- `finalizer`는 예측할 수 없고 상황에 따라 위험할 수 있음
- `cleaner`도 예측할 수 없고, 느리고, 일반적으로 불필요함
- `finalizer`와 `cleaner`는 실행을 보장해야 하는 작업에 사용할 수 없음
- 상태를 영속화하는 작업에서는 `finalizer`, `cleaner`에 의존하면 안됨
- `finalizer`와 `cleaner`는 심각한 성능 문제도 야기함
- 대안으로 `AutoCloseable을` 구현하기

##  try - finally보다 try - with - resource를 사용하기