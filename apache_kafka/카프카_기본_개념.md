## topic
- 데이터를 구분하는 단위
- 1개 이상의 파티션 소유
- 토픽 이름에 `.`, `_`가 함께 있으면 안됨

##  partition
- 큐와 비슷한 구조
- producer가 보내는 데이터를 record 단위로 저장

## record
- 타임스탬프, 메시지 키, 메시지 값, 오프셋으로 구성
- 레코드는 수정할 수 없음
- 메시지 키를 사용하면 producer가 토픽에 레코드를 전송할 때, 메시지 키의 해시를 토대로 파티션을 정함
  - 동일한 메시지 키면 동일한 파티션에 저장됨
- 메시지는 브로커에 저장될 때 직렬화됨
  - 사용하려면 반드시 직렬화와 같은 형태로 역직렬화해야 함

##  broker
- 카프카 클라이언트와 데이터 교환 주체
- 데이터 분산 저장 애플리케이션
  - producer에게 데이터를 받으면 producer가 요청한 토픽의 파티션에 데이터 저장
    - 파일 시스템에 저장 --> 성능을 위해 page cache 사용
    - page cache : OS에서 파일 IO 성능 향상을 위해 만든 메모리 영역
      - 따라서 브로커 실행에 힙 메모리를 크게 할당할 필요가 없음
  - consumer가 요청하면 파티션에 저장된 데이터 전송
- 1 서버 1 브로커 프로세스 실행
- 3대 이상의 브로커 서버를 묶어 운영 --> 클러스터

### 데이터 복제, 싱크
- 데이터 복제 단위는 파티션
- 복제 최솟값 : 1, 최댓값은 브로커 갯수
- 복제
  - 팔로워 파티션은 리더의 오프셋을 확인
  - 자신의 오프셋과 차이를 발견하면
  - 리더로부터 데이터를 내려받아 자신의 파티션에 저장
- 브로커가 다운되면 해당 브로커의 리더 파티션은 사용 불가능
  - 팔로워 파티션 중 하나가 계승함

### 컨트롤러
- 클러스터의 여러 브로커 중 하나가 컨트롤러를 함
- 다른 브로커의 상태 체크
- 리더 파티션 재분배
- 컨트롤러에 장애가 발생하면 다른 브로커가 컨트롤러 계승


### 데이터 삭제
- consumer가 데이터를 가져가도 토픽의 데이터는 삭제되지 않음
- 브로커만 데이터를 삭제할 수 있음
- 삭제는 파일 단위(log segment)
  - 특정 데이터를 골라서 삭제할 수 없음

### 컨슈머 오프셋 저장
- 토픽의 특정 파티션에서 데이터를 받아 처리
- 어느 레코드까지 가져갔는지 확인(오프셋 커밋)
- 커밋한 오프셋은 consumer_offsets(토픽)에 저장

### 코디네이터
- 클러스터의 여러 브로커 중 하나가 코디네이터를 함
- 컨슈머 그룹 상태 체크
- 파티션을 컨슈머에 매칭되도록 분배
- consumer가 그룹에서 빠지면 매칭되지 않은 파티션을 다른 consumer에 할당(리벨런스)

##  zookeeper
- 카프카의 메타데이터 관리
  - 컨트롤러 브로커 정보
  - 저장된 토픽 조회
- 클러스터로 묶인 브로커들은 동일 경로의 주키퍼 경로로 선언해야 같은 카프카 묶음이 됨
- 클러스터 여러개 운영 --> 1 주키퍼에 n개의 카프카 클러스터 연결